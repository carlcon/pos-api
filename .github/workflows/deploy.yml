# POS API - CI/CD Pipeline
# Builds, tests, and deploys Django API to AWS EC2
# Build happens directly on EC2 (no ECR required - $0 cost)

name: Deploy POS API

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  # =============================================================================
  # Job 1: Run Tests
  # =============================================================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: pos_user
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: pos_test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        env:
          DB_NAME: pos_test_db
          DB_USER: pos_user
          DB_PASSWORD: testpassword
          DB_HOST: localhost
          DB_PORT: 5432
          SECRET_KEY: ci-${{ github.run_id }}-${{ github.run_attempt }}-secret
          DEBUG: 'True'
        run: |
          pytest -v --tb=short

  # =============================================================================
  # Job 2: Deploy to EC2 (Build directly on EC2)
  # =============================================================================
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    environment: Production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Add EC2 to known hosts
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts

      - name: Setup SSH key
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          printf '%s' "$EC2_SSH_KEY" | base64 -d > ec2_key.pem
          chmod 600 ec2_key.pem

      - name: Sync code to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          # Sync code to EC2 (excludes unnecessary files)
          rsync -avz --delete \
            --exclude '.git' \
            --exclude '.github' \
            --exclude '__pycache__' \
            --exclude '*.pyc' \
            --exclude '.env' \
            --exclude 'htmlcov' \
            --exclude '.pytest_cache' \
            --exclude 'logs/*.log' \
            -e "ssh -i ec2_key.pem" \
            ./ ec2-user@$EC2_HOST:/opt/pos-app/

      - name: Create environment file on EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          CSRF_TRUSTED_ORIGINS: ${{ secrets.CSRF_TRUSTED_ORIGINS }}
        run: |
          cat > /tmp/.env.production << EOF
          # Production Environment Variables - Auto-generated by CI/CD
          # DO NOT EDIT MANUALLY - Changes will be overwritten on next deployment

          # Django Settings
          SECRET_KEY=${SECRET_KEY}
          DEBUG=False
          ALLOWED_HOSTS=${ALLOWED_HOSTS:-localhost,127.0.0.1}

          # Database Settings
          DB_NAME=${DB_NAME:-pos_db}
          DB_USER=${DB_USER:-pos_user}
          DB_PASSWORD=${DB_PASSWORD}
          DB_HOST=db
          DB_PORT=5432

          # CORS/CSRF Settings
          CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-http://localhost:3000}
          CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS:-http://localhost:3000}

          # Celery Settings
          CELERY_BROKER_URL=redis://redis:6379/0
          CELERY_RESULT_BACKEND=django-db
          EOF
          
          # Remove leading whitespace and copy to EC2
          sed 's/^          //' /tmp/.env.production > /tmp/.env.clean
          scp -i ec2_key.pem /tmp/.env.clean ec2-user@$EC2_HOST:/opt/pos-app/.env
          rm -f /tmp/.env.production /tmp/.env.clean

      - name: Build and deploy on EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          ssh -i ec2_key.pem ec2-user@$EC2_HOST 'bash -s' << 'DEPLOY_SCRIPT'
          cd /opt/pos-app
          
          # Load environment variables
          set -a
          source .env
          set +a
          
          # Build the Docker image directly on EC2
          echo "Building Docker image on EC2..."
          docker build -t pos-api:latest .
          
          # Start database and redis first
          docker-compose -f docker-compose.prod.yml up -d db redis
          
          # Wait for database to be ready
          echo "Waiting for database to be ready..."
          sleep 15
          
          # Stop old application containers
          docker-compose -f docker-compose.prod.yml stop api celery celery-beat 2>/dev/null || true
          docker-compose -f docker-compose.prod.yml rm -f api celery celery-beat 2>/dev/null || true
          
          # Start application services with new image
          docker-compose -f docker-compose.prod.yml up -d api celery celery-beat
          
          # Wait for api to start
          sleep 10
          
          # Run migrations
          docker-compose -f docker-compose.prod.yml exec -T api python manage.py migrate --noinput
          
          # Collect static files
          docker-compose -f docker-compose.prod.yml exec -T api python manage.py collectstatic --noinput
          
          # Clean up old images to save space
          docker image prune -f
          
          echo "Deployment completed successfully!"
          DEPLOY_SCRIPT

      - name: Cleanup SSH key
        if: always()
        run: rm -f ec2_key.pem

      - name: Health check
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          # Wait for services to be ready
          sleep 30
          
          # Check API health with retry logic
          max_retries=5
          retry_count=0
          until curl -sf --max-time 10 http://$EC2_HOST/api/health/ > /dev/null 2>&1; do
            retry_count=$((retry_count + 1))
            if [ $retry_count -ge $max_retries ]; then
              echo "Health check failed after $max_retries attempts"
              exit 1
            fi
            echo "Health check attempt $retry_count failed, retrying in 10s..."
            sleep 10
          done
          
          echo "Health check passed!"

      - name: Notify on failure
        if: failure()
        run: |
          echo "Deployment failed! Check the logs for details."
          # Add Slack/Discord notification here if needed
