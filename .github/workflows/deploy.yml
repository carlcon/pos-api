# POS API - CI/CD Pipeline
# Builds, tests, and deploys Django API to DigitalOcean Droplet
# Build happens directly on the Droplet (no registry required - $0 cost)

name: Deploy POS API

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  # =============================================================================
  # Job 1: Run Tests
  # =============================================================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: pos_user
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: pos_test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        env:
          DB_NAME: pos_test_db
          DB_USER: pos_user
          DB_PASSWORD: testpassword
          DB_HOST: localhost
          DB_PORT: 5432
          SECRET_KEY: ci-${{ github.run_id }}-${{ github.run_attempt }}-secret
          DEBUG: 'True'
        run: |
          pytest -v --tb=short

  # =============================================================================
  # Job 2: Deploy to DigitalOcean Droplet (Build directly on Droplet)
  # =============================================================================
  deploy:
    name: Deploy to DigitalOcean
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    environment: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Add server to known hosts
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H $DO_HOST >> ~/.ssh/known_hosts

      - name: Setup SSH key
        run: |
          echo "${{ secrets.DO_SSH_KEY }}" > do_key.pem
          chmod 600 do_key.pem
          # Debug: verify key format (first/last line only)
          head -1 do_key.pem
          tail -1 do_key.pem

      - name: Check if server needs setup
        id: check_setup
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          # Check if Docker is installed (indicates setup was done)
          if ssh -i do_key.pem root@$DO_HOST 'command -v docker &> /dev/null'; then
            echo "needs_setup=false" >> $GITHUB_OUTPUT
            echo "âœ… Server already configured"
          else
            echo "needs_setup=true" >> $GITHUB_OUTPUT
            echo "ðŸ”§ Server needs initial setup"
          fi

      - name: Run initial server setup
        if: steps.check_setup.outputs.needs_setup == 'true'
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          echo "ðŸš€ Running initial server setup..."
          
          # Copy and run setup script
          scp -i do_key.pem scripts/setup-droplet.sh root@$DO_HOST:/root/setup-droplet.sh
          ssh -i do_key.pem root@$DO_HOST 'chmod +x /root/setup-droplet.sh && /root/setup-droplet.sh'
          
          echo "âœ… Server setup completed"

      - name: Ensure app directory exists
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          ssh -i do_key.pem root@$DO_HOST 'mkdir -p /opt/pos-api && chown root:root /opt/pos-api'

      - name: Sync code to Droplet
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          echo "ðŸ“¦ Syncing code to /opt/pos-api/..."
          # Sync code to Droplet (excludes unnecessary files)
          rsync -avz --delete \
            --exclude '.git' \
            --exclude '.github' \
            --exclude '__pycache__' \
            --exclude '*.pyc' \
            --exclude '.env' \
            --exclude 'htmlcov' \
            --exclude '.pytest_cache' \
            --exclude 'logs/*.log' \
            -e "ssh -i do_key.pem" \
            ./ root@$DO_HOST:/opt/pos-api/
          
          # Verify sync worked
          echo "ðŸ“‚ Verifying files on server..."
          ssh -i do_key.pem root@$DO_HOST 'ls -la /opt/pos-api/ && echo "âœ… Sync verified"'

      - name: Create environment file on Droplet
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          CSRF_TRUSTED_ORIGINS: ${{ secrets.CSRF_TRUSTED_ORIGINS }}
        run: |
          cat > /tmp/.env.production << EOF
          # Production Environment Variables - Auto-generated by CI/CD
          # DO NOT EDIT MANUALLY - Changes will be overwritten on next deployment

          # Django Settings
          SECRET_KEY=${SECRET_KEY}
          DEBUG=False
          ALLOWED_HOSTS=${ALLOWED_HOSTS:-localhost,127.0.0.1}

          # Database Settings
          DB_NAME=${DB_NAME:-pos_db}
          DB_USER=${DB_USER:-pos_user}
          DB_PASSWORD=${DB_PASSWORD}
          DB_HOST=db
          DB_PORT=5432

          # CORS/CSRF Settings
          CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-http://localhost:3000}
          CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS:-http://localhost:3000}

          # Celery disabled for Phase 1 (runs synchronously)
          CELERY_ENABLED=False

          # SSL disabled for HTTP-only deployment (set to True when you add a domain/cert)
          USE_SSL=False
          EOF

          # Remove leading whitespace and copy to Droplet
          sed 's/^          //' /tmp/.env.production > /tmp/.env.clean
          scp -i do_key.pem /tmp/.env.clean root@$DO_HOST:/opt/pos-api/.env
          rm -f /tmp/.env.production /tmp/.env.clean

      - name: Build and deploy on Droplet
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          ssh -i do_key.pem root@$DO_HOST 'bash -s' << 'DEPLOY_SCRIPT'
          cd /opt/pos-api

          # Load environment variables
          set -a
          source .env
          set +a

          # Build the Docker image directly on the Droplet
          echo "Building Docker image on Droplet..."
          docker build -t pos-api:latest .

          # Stop old application containers first
          docker-compose -f docker-compose.prod.yml down 2>/dev/null || true

          # Start database first
          echo "Starting database..."
          docker-compose -f docker-compose.prod.yml up -d db

          # Wait for database to be healthy
          echo "Waiting for database to be ready..."
          for i in {1..30}; do
            if docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U ${DB_USER:-pos_user} -d ${DB_NAME:-pos_db} 2>/dev/null; then
              echo "Database is ready!"
              break
            fi
            echo "Waiting for database... ($i/30)"
            sleep 2
          done

          # Run migrations using docker-compose (proper DNS resolution)
          echo "Running database migrations..."
          docker-compose -f docker-compose.prod.yml run --rm api python manage.py migrate --noinput

          # Collect static files
          echo "Collecting static files..."
          docker-compose -f docker-compose.prod.yml run --rm api python manage.py collectstatic --noinput

          # Start API and Nginx
          echo "Starting services..."
          docker-compose -f docker-compose.prod.yml up -d api nginx

          # Wait for services to be ready
          sleep 30

          # Clean up old images
          docker image prune -f

          echo "Deployment completed!"
          DEPLOY_SCRIPT

      - name: Cleanup SSH key
        if: always()
        run: rm -f do_key.pem

      - name: Health check
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          sleep 10
          max_retries=5
          for i in $(seq 1 $max_retries); do
            if curl -sf --max-time 10 http://$DO_HOST/api/health/; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i/$max_retries failed, retrying in 10s..."
            sleep 10
          done
          echo "Health check failed"
          exit 1

      - name: Notify on failure
        if: failure()
        run: |
          echo "Deployment failed! Check the logs for details."
          # Add Slack/Discord notification here if needed
