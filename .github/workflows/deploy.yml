# POS API - CI/CD Pipeline
# Builds, tests, and deploys Django API to DigitalOcean Droplet
# Build happens directly on the Droplet (no registry required - $0 cost)

name: Deploy POS API

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  # =============================================================================
  # Job 1: Run Tests
  # =============================================================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: pos_user
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: pos_test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        env:
          DB_NAME: pos_test_db
          DB_USER: pos_user
          DB_PASSWORD: testpassword
          DB_HOST: localhost
          DB_PORT: 5432
          SECRET_KEY: ci-${{ github.run_id }}-${{ github.run_attempt }}-secret
          DEBUG: 'True'
        run: |
          pytest -v --tb=short

  # =============================================================================
  # Job 2: Deploy to DigitalOcean Droplet (Build directly on Droplet)
  # =============================================================================
  deploy:
    name: Deploy to DigitalOcean
    runs-on: ubuntu-latest
    # needs: test  # Temporarily disabled - uncomment to require tests to pass
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    environment: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Add server to known hosts
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H $DO_HOST >> ~/.ssh/known_hosts

      - name: Setup SSH key
        run: |
          echo "${{ secrets.DO_SSH_KEY }}" > do_key.pem
          chmod 600 do_key.pem
          # Debug: verify key format (first/last line only)
          head -1 do_key.pem
          tail -1 do_key.pem

      - name: Check if server needs setup
        id: check_setup
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          # Check if Docker is installed (indicates setup was done)
          if ssh -i do_key.pem root@$DO_HOST 'command -v docker &> /dev/null'; then
            echo "needs_setup=false" >> $GITHUB_OUTPUT
            echo "âœ… Server already configured"
          else
            echo "needs_setup=true" >> $GITHUB_OUTPUT
            echo "ðŸ”§ Server needs initial setup"
          fi

      - name: Run initial server setup
        if: steps.check_setup.outputs.needs_setup == 'true'
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          echo "ðŸš€ Running initial server setup..."
          
          # Copy and run setup script
          scp -i do_key.pem scripts/setup-droplet.sh root@$DO_HOST:/root/setup-droplet.sh
          ssh -i do_key.pem root@$DO_HOST 'chmod +x /root/setup-droplet.sh && /root/setup-droplet.sh'
          
          echo "âœ… Server setup completed"

      - name: Ensure app directory exists
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          ssh -i do_key.pem root@$DO_HOST 'mkdir -p /opt/pos-api && chown root:root /opt/pos-api'

      - name: Sync code to Droplet
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          echo "ðŸ“¦ Syncing code to /opt/pos-api/..."
          # Sync code to Droplet (excludes unnecessary files)
          rsync -avz --delete \
            --exclude '.git' \
            --exclude '.github' \
            --exclude '__pycache__' \
            --exclude '*.pyc' \
            --exclude '*.pem' \
            --exclude '.env' \
            --exclude 'htmlcov' \
            --exclude '.pytest_cache' \
            --exclude 'logs/*.log' \
            --exclude '.claude' \
            -e "ssh -i do_key.pem" \
            ./ root@$DO_HOST:/opt/pos-api/
          
          # Verify sync worked
          echo "ðŸ“‚ Verifying files on server..."
          ssh -i do_key.pem root@$DO_HOST 'ls -la /opt/pos-api/ && echo "âœ… Sync verified"'

      - name: Create environment file on Droplet
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          CSRF_TRUSTED_ORIGINS: ${{ secrets.CSRF_TRUSTED_ORIGINS }}
        run: |
          # Create .env file directly on the server
          # Using quotes to protect against special characters in secrets
          ssh -i do_key.pem root@$DO_HOST "cat > /opt/pos-api/.env" << ENVFILE
          SECRET_KEY="${SECRET_KEY}"
          DEBUG=False
          ALLOWED_HOSTS="${ALLOWED_HOSTS:-localhost,127.0.0.1}"
          DB_NAME="${DB_NAME:-pos_db}"
          DB_USER="${DB_USER:-pos_user}"
          DB_PASSWORD="${DB_PASSWORD}"
          DB_HOST=db
          DB_PORT=5432
          CORS_ALLOWED_ORIGINS="${CORS_ALLOWED_ORIGINS:-http://localhost:3000}"
          CSRF_TRUSTED_ORIGINS="${CSRF_TRUSTED_ORIGINS:-http://localhost:3000}"
          CELERY_ENABLED=False
          USE_SSL=False
          ENVFILE
          
          # Verify .env was created (show non-sensitive vars only)
          echo "âœ… .env file created. Contents (sanitized):"
          ssh -i do_key.pem root@$DO_HOST "grep -E '^(DEBUG|DB_NAME|DB_USER|DB_HOST|ALLOWED_HOSTS|CELERY_ENABLED)=' /opt/pos-api/.env"

      - name: Build and deploy on Droplet
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          ssh -i do_key.pem root@$DO_HOST 'bash -s' << 'DEPLOY_SCRIPT'
          set -e  # Exit on any error
          cd /opt/pos-api

          echo "=========================================="
          echo "Step 1: Verify .env file exists"
          echo "=========================================="
          if [ ! -f .env ]; then
            echo "ERROR: .env file not found!"
            exit 1
          fi
          echo "âœ… .env file found"
          
          # Show env vars (hide sensitive values)
          echo "Environment variables loaded:"
          grep -E "^(DB_NAME|DB_USER|DB_HOST|ALLOWED_HOSTS)=" .env || true

          echo "=========================================="
          echo "Step 2: Build Docker image"
          echo "=========================================="
          docker build -t pos-api:latest .

          echo "=========================================="
          echo "Step 3: Stop and clean up old containers"
          echo "=========================================="
          # Stop all project containers
          docker stop pos-nginx pos-api pos-db 2>/dev/null || true
          docker rm pos-nginx pos-api pos-db 2>/dev/null || true
          
          # Remove the old network (might have wrong labels)
          docker network rm pos-network 2>/dev/null || true
          
          echo "âœ… Cleanup complete"

          echo "=========================================="
          echo "Step 4: Start database"
          echo "=========================================="
          # Load DB credentials from .env
          source .env
          echo "Using DB_USER=$DB_USER, DB_NAME=$DB_NAME"
          
          # Start only the database service
          docker-compose --env-file .env -f docker-compose.prod.yml up -d db
          
          # Wait for database with proper health check
          echo "Waiting for database to be ready..."
          for i in $(seq 1 60); do
            if docker exec pos-db pg_isready -U "$DB_USER" -d "$DB_NAME" 2>/dev/null; then
              echo "âœ… Database is ready!"
              break
            fi
            
            # Check if container is running
            if ! docker ps | grep -q pos-db; then
              echo "ERROR: Database container is not running!"
              docker logs pos-db --tail 30 2>/dev/null || echo "No logs available"
              exit 1
            fi
            
            echo "Waiting for database... ($i/60)"
            sleep 2
          done

          # Final check
          if ! docker exec pos-db pg_isready -U "$DB_USER" -d "$DB_NAME" 2>/dev/null; then
            echo "ERROR: Database failed to become ready after 2 minutes"
            docker logs pos-db --tail 50
            exit 1
          fi

          echo "=========================================="
          echo "Step 5: Run migrations"
          echo "=========================================="
          docker-compose --env-file .env -f docker-compose.prod.yml run --rm api python manage.py migrate --noinput

          echo "=========================================="
          echo "Step 6: Collect static files"
          echo "=========================================="
          docker-compose --env-file .env -f docker-compose.prod.yml run --rm api python manage.py collectstatic --noinput

          echo "=========================================="
          echo "Step 7: Start API and Nginx"
          echo "=========================================="
          docker-compose --env-file .env -f docker-compose.prod.yml up -d api
          
          # Wait for API to be healthy before starting Nginx
          echo "Waiting for API to be ready..."
          for i in $(seq 1 30); do
            if docker exec pos-api python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/api/health/')" 2>/dev/null; then
              echo "âœ… API is ready!"
              break
            fi
            
            if ! docker ps | grep -q pos-api; then
              echo "ERROR: API container is not running!"
              docker logs pos-api --tail 50 2>/dev/null || echo "No logs available"
              exit 1
            fi
            
            echo "Waiting for API... ($i/30)"
            sleep 2
          done

          # Start Nginx
          docker-compose --env-file .env -f docker-compose.prod.yml up -d nginx

          echo "=========================================="
          echo "Step 8: Verify deployment"
          echo "=========================================="
          echo "Running containers:"
          docker ps
          
          echo ""
          echo "Testing health endpoint internally:"
          sleep 5
          curl -s http://localhost/api/health/ || echo "Health check via nginx failed"

          # Clean up old images
          docker image prune -f

          echo "=========================================="
          echo "âœ… Deployment completed successfully!"
          echo "=========================================="
          DEPLOY_SCRIPT

      - name: Cleanup SSH key
        if: always()
        run: rm -f do_key.pem

      - name: Health check
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
        run: |
          sleep 10
          max_retries=5
          for i in $(seq 1 $max_retries); do
            if curl -sf --max-time 10 http://$DO_HOST/api/health/; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i/$max_retries failed, retrying in 10s..."
            sleep 10
          done
          echo "Health check failed"
          exit 1

      - name: Notify on failure
        if: failure()
        run: |
          echo "Deployment failed! Check the logs for details."
          # Add Slack/Discord notification here if needed
